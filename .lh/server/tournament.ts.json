{
    "sourceFile": "server/tournament.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 7,
            "patches": [
                {
                    "date": 1763989257102,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764013138270,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,8 +32,9 @@\n     id: string;\r\n     round: number;\r\n     players: string[];\r\n     matchId: string;\r\n+    name?: string; // Custom group name\r\n }\r\n \r\n export interface BracketMatch {\r\n     id: string;\r\n"
                },
                {
                    "date": 1764013150785,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -509,16 +509,16 @@\n \r\n     submitBracketWinner(matchId: string, winnerId: string) {\r\n         const match = this.bracketMatches.find(m => m.id === matchId);\r\n         if (!match) throw new Error(\"Match not found\");\r\n-        \r\n+\r\n         if (match.player1Id !== winnerId && match.player2Id !== winnerId) {\r\n             throw new Error(\"Winner must be one of the players in the match\");\r\n         }\r\n \r\n         match.winnerId = winnerId;\r\n         const loserId = match.player1Id === winnerId ? match.player2Id : match.player1Id;\r\n-        \r\n+\r\n         // Advance winner to next match\r\n         if (match.nextMatchId) {\r\n             const nextMatch = this.bracketMatches.find(m => m.id === match.nextMatchId);\r\n             if (nextMatch) {\r\n@@ -528,9 +528,9 @@\n                     nextMatch.player2Id = winnerId;\r\n                 }\r\n             }\r\n         }\r\n-        \r\n+\r\n         // If this is a semifinal, send loser to third place match\r\n         if (match.bracketType === 'semifinals') {\r\n             const thirdPlaceMatch = this.bracketMatches.find(m => m.bracketType === '3rd-place');\r\n             if (thirdPlaceMatch && loserId) {\r\n@@ -542,5 +542,40 @@\n                 }\r\n             }\r\n         }\r\n     }\r\n+\r\n+    // Update group name\r\n+    updateGroupName(podId: string, name: string) {\r\n+        const pod = this.pods.find(p => p.id === podId);\r\n+        if (!pod) throw new Error(\"Group not found\");\r\n+\r\n+        pod.name = name.trim() || undefined;\r\n+    }\r\n+\r\n+    // Reset group data (clear all match results for players in this group)\r\n+    resetGroupData(podId: string) {\r\n+        const pod = this.pods.find(p => p.id === podId);\r\n+        if (!pod) throw new Error(\"Group not found\");\r\n+\r\n+        // Reset player stats for players in this group\r\n+        pod.players.forEach(playerId => {\r\n+            const player = this.players.find(p => p.id === playerId);\r\n+            if (player) {\r\n+                player.points = 0;\r\n+                player.matchesPlayed = 0;\r\n+                player.wins = 0;\r\n+                player.draws = 0;\r\n+                player.losses = 0;\r\n+                player.scoreDifferential = 0;\r\n+            }\r\n+        });\r\n+\r\n+        // Reset all matches for this group\r\n+        this.matches.forEach(match => {\r\n+            if (match.podId === podId) {\r\n+                match.result = undefined;\r\n+                match.completed = false;\r\n+            }\r\n+        });\r\n+    }\r\n }\r\n"
                },
                {
                    "date": 1764016797155,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -543,8 +543,16 @@\n             }\r\n         }\r\n     }\r\n \r\n+    // Update tournament name\r\n+    updateTournamentName(name: string) {\r\n+        if (!name?.trim()) {\r\n+            throw new Error(\"Tournament name cannot be empty\");\r\n+        }\r\n+        this.name = name.trim();\r\n+    }\r\n+\r\n     // Update group name\r\n     updateGroupName(podId: string, name: string) {\r\n         const pod = this.pods.find(p => p.id === podId);\r\n         if (!pod) throw new Error(\"Group not found\");\r\n"
                },
                {
                    "date": 1764018253998,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -585,5 +585,13 @@\n                 match.completed = false;\r\n             }\r\n         });\r\n     }\r\n+\r\n+    // Update player name\r\n+    updatePlayerName(playerId: string, name: string) {\r\n+        if (!name || !name.trim()) throw new Error('Name cannot be empty');\r\n+        const p = this.players.find(pl => pl.id === playerId);\r\n+        if (!p) throw new Error('Player not found');\r\n+        p.name = name.trim();\r\n+    }\r\n }\r\n"
                },
                {
                    "date": 1764022977082,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -541,8 +541,13 @@\n                     thirdPlaceMatch.player2Id = loserId;\r\n                 }\r\n             }\r\n         }\r\n+\r\n+        // If this is the final match, mark tournament as completed\r\n+        if (match.bracketType === 'finals') {\r\n+            this.state = 'completed';\r\n+        }\r\n     }\r\n \r\n     // Update tournament name\r\n     updateTournamentName(name: string) {\r\n"
                },
                {
                    "date": 1764023138476,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,9 +56,9 @@\n     players: Player[] = [];\r\n     pods: Pod[] = [];\r\n     matches: Match[] = [];\r\n     bracketMatches: BracketMatch[] = [];\r\n-    state: 'registration' | 'group' | 'playoffs' = 'registration';\r\n+    state: 'registration' | 'group' | 'playoffs' | 'completed' = 'registration';\r\n \r\n     constructor(id: string, name: string) {\r\n         this.id = id;\r\n         this.name = name;\r\n"
                },
                {
                    "date": 1764023367143,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -542,10 +542,11 @@\n                 }\r\n             }\r\n         }\r\n \r\n-        // If this is the final match, mark tournament as completed\r\n-        if (match.bracketType === 'finals') {\r\n+        // Check if all bracket matches are completed\r\n+        const allBracketMatchesCompleted = this.bracketMatches.every(m => m.winnerId);\r\n+        if (allBracketMatchesCompleted) {\r\n             this.state = 'completed';\r\n         }\r\n     }\r\n \r\n"
                }
            ],
            "date": 1763989257102,
            "name": "Commit-0",
            "content": "import { v4 as uuidv4 } from 'uuid';\r\n\r\nexport interface Player {\r\n    id: string;\r\n    name: string;\r\n    points: number;\r\n    matchesPlayed: number;\r\n    wins: number;\r\n    draws: number;\r\n    losses: number;\r\n    scoreDifferential: number; // For tiebreakers\r\n}\r\n\r\nexport interface Match {\r\n    id: string;\r\n    podId: string;\r\n    round: number; // Which round this match belongs to (1, 2, or 3)\r\n    player1Id: string;\r\n    player2Id: string;\r\n    players: string[]; // IDs of players in this match\r\n    result?: {\r\n        [playerId: string]: {\r\n            rank?: number; // 1st, 2nd, 3rd, 4th\r\n            points: number; // 3, 1, 0\r\n            score?: number; // In-game score\r\n        }\r\n    };\r\n    completed: boolean;\r\n}\r\n\r\nexport interface Pod {\r\n    id: string;\r\n    round: number;\r\n    players: string[];\r\n    matchId: string;\r\n}\r\n\r\nexport interface BracketMatch {\r\n    id: string;\r\n    round: number;\r\n    player1Id?: string;\r\n    player2Id?: string;\r\n    winnerId?: string;\r\n    nextMatchId?: string; // Where the winner goes\r\n    nextMatchSlot?: 1 | 2; // Player 1 or Player 2 slot\r\n    bracketType: 'quarterfinals' | 'semifinals' | 'finals' | '3rd-place';\r\n    matchLabel?: string; // e.g., \"Semifinal 1\", \"Grand Final\"\r\n    loserFromMatch1?: string; // For 3rd place match\r\n    loserFromMatch2?: string; // For 3rd place match\r\n}\r\n\r\nexport class TournamentManager {\r\n    id: string;\r\n    name: string;\r\n    players: Player[] = [];\r\n    pods: Pod[] = [];\r\n    matches: Match[] = [];\r\n    bracketMatches: BracketMatch[] = [];\r\n    state: 'registration' | 'group' | 'playoffs' = 'registration';\r\n\r\n    constructor(id: string, name: string) {\r\n        this.id = id;\r\n        this.name = name;\r\n    }\r\n\r\n    addPlayer(name: string): Player {\r\n        const player: Player = {\r\n            id: uuidv4(),\r\n            name,\r\n            points: 0,\r\n            matchesPlayed: 0,\r\n            wins: 0,\r\n            draws: 0,\r\n            losses: 0,\r\n            scoreDifferential: 0\r\n        };\r\n        this.players.push(player);\r\n        return player;\r\n    }\r\n\r\n    startGroupStage() {\r\n        if (this.players.length < 4) {\r\n            throw new Error(\"Need at least 4 players\");\r\n        }\r\n        this.state = 'group';\r\n        this.generatePods();\r\n    }\r\n\r\n    private generatePods() {\r\n        const numPlayers = this.players.length;\r\n        \r\n        // Determine group size and count\r\n        let groupSize = 4;\r\n        let numGroups = 1;\r\n        \r\n        if (numPlayers === 4) {\r\n            groupSize = 4;\r\n            numGroups = 1;\r\n        } else if (numPlayers === 5) {\r\n            groupSize = 5;\r\n            numGroups = 1;\r\n        } else if (numPlayers === 6) {\r\n            groupSize = 3;\r\n            numGroups = 2;\r\n        } else if (numPlayers === 7) {\r\n            groupSize = 7;\r\n            numGroups = 1;\r\n        } else if (numPlayers === 8) {\r\n            groupSize = 4;\r\n            numGroups = 2;\r\n        } else if (numPlayers === 9) {\r\n            groupSize = 3;\r\n            numGroups = 3;\r\n        } else if (numPlayers >= 10 && numPlayers <= 12) {\r\n            groupSize = 4;\r\n            numGroups = Math.ceil(numPlayers / 4);\r\n        } else {\r\n            // For larger numbers, try to make groups of 4\r\n            groupSize = 4;\r\n            numGroups = Math.ceil(numPlayers / 4);\r\n        }\r\n        \r\n        // Shuffle and divide players into groups\r\n        const shuffled = [...this.players].sort(() => Math.random() - 0.5);\r\n        const groups: Player[][] = [];\r\n        \r\n        for (let g = 0; g < numGroups; g++) {\r\n            groups.push([]);\r\n        }\r\n        \r\n        // Distribute players evenly\r\n        shuffled.forEach((player, index) => {\r\n            groups[index % numGroups].push(player);\r\n        });\r\n        \r\n        // For each group, generate complete round-robin matches\r\n        groups.forEach((groupPlayers, groupIndex) => {\r\n            const podId = uuidv4();\r\n            \r\n            // Store pod with all players in this group\r\n            this.pods.push({\r\n                id: podId,\r\n                round: 1, // All belong to the same logical group\r\n                players: groupPlayers.map(p => p.id),\r\n                matchId: '' // Will be set later\r\n            });\r\n            \r\n            // Generate complete round-robin: every player plays every other player once\r\n            const n = groupPlayers.length;\r\n            \r\n            if (n < 2) return; // Need at least 2 players\r\n            \r\n            // For round-robin, generate all unique pairs\r\n            const allMatches: [Player, Player][] = [];\r\n            for (let i = 0; i < n; i++) {\r\n                for (let j = i + 1; j < n; j++) {\r\n                    allMatches.push([groupPlayers[i], groupPlayers[j]]);\r\n                }\r\n            }\r\n            \r\n            // Distribute matches across rounds to minimize conflicts\r\n            // Use round-robin scheduling algorithm\r\n            const totalMatches = allMatches.length;\r\n            const matchesPerRound = Math.floor(n / 2);\r\n            const totalRounds = n % 2 === 0 ? n - 1 : n;\r\n            \r\n            const schedule: [Player, Player][][] = [];\r\n            const playersCopy = [...groupPlayers];\r\n            \r\n            for (let round = 0; round < totalRounds; round++) {\r\n                const roundMatches: [Player, Player][] = [];\r\n                \r\n                for (let i = 0; i < matchesPerRound; i++) {\r\n                    const p1 = playersCopy[i];\r\n                    const p2 = playersCopy[n - 1 - i];\r\n                    if (p1 && p2) {\r\n                        roundMatches.push([p1, p2]);\r\n                    }\r\n                }\r\n                \r\n                schedule.push(roundMatches);\r\n                \r\n                // Rotate players for next round (keep first player fixed)\r\n                if (n % 2 === 0) {\r\n                    // For even number of players, rotate all except first\r\n                    const last = playersCopy.pop()!;\r\n                    playersCopy.splice(1, 0, last);\r\n                } else {\r\n                    // For odd number of players, rotate all\r\n                    playersCopy.push(playersCopy.shift()!);\r\n                }\r\n            }\r\n            \r\n            // Create matches for each round\r\n            schedule.forEach((roundMatches, roundIndex) => {\r\n                roundMatches.forEach(([p1, p2]) => {\r\n                    const matchId = uuidv4();\r\n                    this.matches.push({\r\n                        id: matchId,\r\n                        podId,\r\n                        round: roundIndex + 1, // Store the round number\r\n                        player1Id: p1.id,\r\n                        player2Id: p2.id,\r\n                        players: [p1.id, p2.id],\r\n                        completed: false\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    submitMatchResult(matchId: string, results: { [playerId: string]: { points: number, score?: number } }) {\r\n        const match = this.matches.find(m => m.id === matchId);\r\n        if (!match) throw new Error(\"Match not found\");\r\n\r\n        match.result = results;\r\n        match.completed = true;\r\n\r\n        // Update player stats\r\n        for (const [playerId, result] of Object.entries(results)) {\r\n            const player = this.players.find(p => p.id === playerId);\r\n            if (player) {\r\n                player.matchesPlayed++;\r\n                player.points += result.points;\r\n                if (result.points >= 3) player.wins++; // Assuming 3 is win\r\n                else if (result.points === 1) player.draws++;\r\n                else player.losses++;\r\n                // Score diff logic if needed\r\n            }\r\n        }\r\n    }\r\n\r\n    getRankings(): Player[] {\r\n        return [...this.players].sort((a, b) => {\r\n            if (b.points !== a.points) return b.points - a.points;\r\n            // Tiebreakers\r\n            return 0; // TODO: Add tiebreakers\r\n        });\r\n    }\r\n\r\n    generateBrackets() {\r\n        const rankings = this.getRankings();\r\n        \r\n        // Determine playoff size based on total players\r\n        const totalPlayers = rankings.length;\r\n        let numQualified: number;\r\n        \r\n        if (totalPlayers <= 5) {\r\n            // 4-5 players: top 4 advance\r\n            numQualified = Math.min(4, totalPlayers);\r\n        } else if (totalPlayers <= 8) {\r\n            // 6-8 players: top 4 advance (simple bracket)\r\n            numQualified = 4;\r\n        } else if (totalPlayers <= 13) {\r\n            // 9-13 players: top 6 advance (quarterfinals with byes)\r\n            numQualified = 6;\r\n        } else {\r\n            // 14+ players: top 8 advance\r\n            numQualified = 8;\r\n        }\r\n        \r\n        const qualifiedPlayers = rankings.slice(0, numQualified);\r\n\r\n        this.bracketMatches = [];\r\n        this.createPlayoffBracket(qualifiedPlayers);\r\n        this.state = 'playoffs';\r\n    }\r\n\r\n    private createPlayoffBracket(players: Player[]) {\r\n        const numPlayers = players.length;\r\n        \r\n        if (numPlayers === 4) {\r\n            this.create4PlayerBracket(players);\r\n        } else if (numPlayers === 6) {\r\n            this.create6PlayerBracket(players);\r\n        } else if (numPlayers === 8) {\r\n            this.create8PlayerBracket(players);\r\n        } else {\r\n            // Fallback: just create semifinals with available players\r\n            this.create4PlayerBracket(players.slice(0, 4));\r\n        }\r\n    }\r\n    \r\n    private create4PlayerBracket(players: Player[]) {\r\n        // 4 players: 2 semifinals → finals + 3rd place\r\n        const semi1Id = uuidv4();\r\n        const semi2Id = uuidv4();\r\n        const thirdPlaceId = uuidv4();\r\n        const finalId = uuidv4();\r\n        \r\n        // Semifinals\r\n        this.bracketMatches.push({\r\n            id: semi1Id,\r\n            round: 1,\r\n            bracketType: 'semifinals',\r\n            matchLabel: 'Semifinal 1',\r\n            player1Id: players[0].id, // 1st seed\r\n            player2Id: players[3].id, // 4th seed\r\n            nextMatchId: finalId,\r\n            nextMatchSlot: 1\r\n        });\r\n        \r\n        this.bracketMatches.push({\r\n            id: semi2Id,\r\n            round: 1,\r\n            bracketType: 'semifinals',\r\n            matchLabel: 'Semifinal 2',\r\n            player1Id: players[1].id, // 2nd seed\r\n            player2Id: players[2].id, // 3rd seed\r\n            nextMatchId: finalId,\r\n            nextMatchSlot: 2\r\n        });\r\n        \r\n        // Third place match\r\n        this.bracketMatches.push({\r\n            id: thirdPlaceId,\r\n            round: 2,\r\n            bracketType: '3rd-place',\r\n            matchLabel: '3rd Place Match',\r\n            loserFromMatch1: semi1Id,\r\n            loserFromMatch2: semi2Id\r\n        });\r\n        \r\n        // Final\r\n        this.bracketMatches.push({\r\n            id: finalId,\r\n            round: 2,\r\n            bracketType: 'finals',\r\n            matchLabel: 'Grand Final'\r\n        });\r\n    }\r\n    \r\n    private create6PlayerBracket(players: Player[]) {\r\n        // 6 players: 2 quarterfinals → 2 semifinals → finals + 3rd place\r\n        // Seeds 1 and 2 get automatic advancement to semifinals (no bye matches shown)\r\n        // Seeds 3-6 play in quarterfinals\r\n        \r\n        const quarter1Id = uuidv4();\r\n        const quarter2Id = uuidv4();\r\n        const semi1Id = uuidv4();\r\n        const semi2Id = uuidv4();\r\n        const thirdPlaceId = uuidv4();\r\n        const finalId = uuidv4();\r\n        \r\n        // Quarterfinals (2 matches)\r\n        // Match 1: 3rd vs 6th → winner plays 2nd seed\r\n        this.bracketMatches.push({\r\n            id: quarter1Id,\r\n            round: 1,\r\n            bracketType: 'quarterfinals',\r\n            matchLabel: 'Quarterfinal 1',\r\n            player1Id: players[2].id, // 3rd seed\r\n            player2Id: players[5].id, // 6th seed\r\n            nextMatchId: semi2Id,\r\n            nextMatchSlot: 2\r\n        });\r\n        \r\n        // Match 2: 4th vs 5th → winner plays 1st seed\r\n        this.bracketMatches.push({\r\n            id: quarter2Id,\r\n            round: 1,\r\n            bracketType: 'quarterfinals',\r\n            matchLabel: 'Quarterfinal 2',\r\n            player1Id: players[3].id, // 4th seed\r\n            player2Id: players[4].id, // 5th seed\r\n            nextMatchId: semi1Id,\r\n            nextMatchSlot: 2\r\n        });\r\n        \r\n        // Semifinals (2 matches)\r\n        // Semi 1: 1st seed (bye) vs winner of QF2\r\n        this.bracketMatches.push({\r\n            id: semi1Id,\r\n            round: 2,\r\n            bracketType: 'semifinals',\r\n            matchLabel: 'Semifinal 1',\r\n            player1Id: players[0].id, // 1st seed (bye)\r\n            // player2Id filled by QF2 winner\r\n            nextMatchId: finalId,\r\n            nextMatchSlot: 1\r\n        });\r\n        \r\n        // Semi 2: 2nd seed (bye) vs winner of QF1\r\n        this.bracketMatches.push({\r\n            id: semi2Id,\r\n            round: 2,\r\n            bracketType: 'semifinals',\r\n            matchLabel: 'Semifinal 2',\r\n            player1Id: players[1].id, // 2nd seed (bye)\r\n            // player2Id filled by QF1 winner\r\n            nextMatchId: finalId,\r\n            nextMatchSlot: 2\r\n        });\r\n        \r\n        // Third place match\r\n        this.bracketMatches.push({\r\n            id: thirdPlaceId,\r\n            round: 3,\r\n            bracketType: '3rd-place',\r\n            matchLabel: '3rd Place Match',\r\n            loserFromMatch1: semi1Id,\r\n            loserFromMatch2: semi2Id\r\n        });\r\n        \r\n        // Final\r\n        this.bracketMatches.push({\r\n            id: finalId,\r\n            round: 3,\r\n            bracketType: 'finals',\r\n            matchLabel: 'Grand Final'\r\n        });\r\n    }\r\n    \r\n    private create8PlayerBracket(players: Player[]) {\r\n        // 8 players: 4 quarterfinals → 2 semifinals → finals + 3rd place\r\n        \r\n        const quarter1Id = uuidv4();\r\n        const quarter2Id = uuidv4();\r\n        const quarter3Id = uuidv4();\r\n        const quarter4Id = uuidv4();\r\n        const semi1Id = uuidv4();\r\n        const semi2Id = uuidv4();\r\n        const thirdPlaceId = uuidv4();\r\n        const finalId = uuidv4();\r\n        \r\n        // Quarterfinals (4 matches)\r\n        this.bracketMatches.push({\r\n            id: quarter1Id,\r\n            round: 1,\r\n            bracketType: 'quarterfinals',\r\n            matchLabel: 'Quarterfinal 1',\r\n            player1Id: players[0].id, // 1st vs 8th\r\n            player2Id: players[7].id,\r\n            nextMatchId: semi1Id,\r\n            nextMatchSlot: 1\r\n        });\r\n        \r\n        this.bracketMatches.push({\r\n            id: quarter2Id,\r\n            round: 1,\r\n            bracketType: 'quarterfinals',\r\n            matchLabel: 'Quarterfinal 2',\r\n            player1Id: players[3].id, // 4th vs 5th\r\n            player2Id: players[4].id,\r\n            nextMatchId: semi1Id,\r\n            nextMatchSlot: 2\r\n        });\r\n        \r\n        this.bracketMatches.push({\r\n            id: quarter3Id,\r\n            round: 1,\r\n            bracketType: 'quarterfinals',\r\n            matchLabel: 'Quarterfinal 3',\r\n            player1Id: players[1].id, // 2nd vs 7th\r\n            player2Id: players[6].id,\r\n            nextMatchId: semi2Id,\r\n            nextMatchSlot: 1\r\n        });\r\n        \r\n        this.bracketMatches.push({\r\n            id: quarter4Id,\r\n            round: 1,\r\n            bracketType: 'quarterfinals',\r\n            matchLabel: 'Quarterfinal 4',\r\n            player1Id: players[2].id, // 3rd vs 6th\r\n            player2Id: players[5].id,\r\n            nextMatchId: semi2Id,\r\n            nextMatchSlot: 2\r\n        });\r\n        \r\n        // Semifinals (2 matches)\r\n        this.bracketMatches.push({\r\n            id: semi1Id,\r\n            round: 2,\r\n            bracketType: 'semifinals',\r\n            matchLabel: 'Semifinal 1',\r\n            nextMatchId: finalId,\r\n            nextMatchSlot: 1\r\n        });\r\n        \r\n        this.bracketMatches.push({\r\n            id: semi2Id,\r\n            round: 2,\r\n            bracketType: 'semifinals',\r\n            matchLabel: 'Semifinal 2',\r\n            nextMatchId: finalId,\r\n            nextMatchSlot: 2\r\n        });\r\n        \r\n        // Third place match\r\n        this.bracketMatches.push({\r\n            id: thirdPlaceId,\r\n            round: 3,\r\n            bracketType: '3rd-place',\r\n            matchLabel: '3rd Place Match',\r\n            loserFromMatch1: semi1Id,\r\n            loserFromMatch2: semi2Id\r\n        });\r\n        \r\n        // Final\r\n        this.bracketMatches.push({\r\n            id: finalId,\r\n            round: 3,\r\n            bracketType: 'finals',\r\n            matchLabel: 'Grand Final'\r\n        });\r\n    }\r\n\r\n    submitBracketWinner(matchId: string, winnerId: string) {\r\n        const match = this.bracketMatches.find(m => m.id === matchId);\r\n        if (!match) throw new Error(\"Match not found\");\r\n        \r\n        if (match.player1Id !== winnerId && match.player2Id !== winnerId) {\r\n            throw new Error(\"Winner must be one of the players in the match\");\r\n        }\r\n\r\n        match.winnerId = winnerId;\r\n        const loserId = match.player1Id === winnerId ? match.player2Id : match.player1Id;\r\n        \r\n        // Advance winner to next match\r\n        if (match.nextMatchId) {\r\n            const nextMatch = this.bracketMatches.find(m => m.id === match.nextMatchId);\r\n            if (nextMatch) {\r\n                if (match.nextMatchSlot === 1) {\r\n                    nextMatch.player1Id = winnerId;\r\n                } else {\r\n                    nextMatch.player2Id = winnerId;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // If this is a semifinal, send loser to third place match\r\n        if (match.bracketType === 'semifinals') {\r\n            const thirdPlaceMatch = this.bracketMatches.find(m => m.bracketType === '3rd-place');\r\n            if (thirdPlaceMatch && loserId) {\r\n                // Add loser to third place match\r\n                if (!thirdPlaceMatch.player1Id) {\r\n                    thirdPlaceMatch.player1Id = loserId;\r\n                } else if (!thirdPlaceMatch.player2Id) {\r\n                    thirdPlaceMatch.player2Id = loserId;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"
        }
    ]
}