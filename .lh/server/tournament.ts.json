{
    "sourceFile": "server/tournament.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 12,
            "patches": [
                {
                    "date": 1763989257102,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764013138270,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,8 +32,9 @@\n     id: string;\r\n     round: number;\r\n     players: string[];\r\n     matchId: string;\r\n+    name?: string; // Custom group name\r\n }\r\n \r\n export interface BracketMatch {\r\n     id: string;\r\n"
                },
                {
                    "date": 1764013150785,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -509,16 +509,16 @@\n \r\n     submitBracketWinner(matchId: string, winnerId: string) {\r\n         const match = this.bracketMatches.find(m => m.id === matchId);\r\n         if (!match) throw new Error(\"Match not found\");\r\n-        \r\n+\r\n         if (match.player1Id !== winnerId && match.player2Id !== winnerId) {\r\n             throw new Error(\"Winner must be one of the players in the match\");\r\n         }\r\n \r\n         match.winnerId = winnerId;\r\n         const loserId = match.player1Id === winnerId ? match.player2Id : match.player1Id;\r\n-        \r\n+\r\n         // Advance winner to next match\r\n         if (match.nextMatchId) {\r\n             const nextMatch = this.bracketMatches.find(m => m.id === match.nextMatchId);\r\n             if (nextMatch) {\r\n@@ -528,9 +528,9 @@\n                     nextMatch.player2Id = winnerId;\r\n                 }\r\n             }\r\n         }\r\n-        \r\n+\r\n         // If this is a semifinal, send loser to third place match\r\n         if (match.bracketType === 'semifinals') {\r\n             const thirdPlaceMatch = this.bracketMatches.find(m => m.bracketType === '3rd-place');\r\n             if (thirdPlaceMatch && loserId) {\r\n@@ -542,5 +542,40 @@\n                 }\r\n             }\r\n         }\r\n     }\r\n+\r\n+    // Update group name\r\n+    updateGroupName(podId: string, name: string) {\r\n+        const pod = this.pods.find(p => p.id === podId);\r\n+        if (!pod) throw new Error(\"Group not found\");\r\n+\r\n+        pod.name = name.trim() || undefined;\r\n+    }\r\n+\r\n+    // Reset group data (clear all match results for players in this group)\r\n+    resetGroupData(podId: string) {\r\n+        const pod = this.pods.find(p => p.id === podId);\r\n+        if (!pod) throw new Error(\"Group not found\");\r\n+\r\n+        // Reset player stats for players in this group\r\n+        pod.players.forEach(playerId => {\r\n+            const player = this.players.find(p => p.id === playerId);\r\n+            if (player) {\r\n+                player.points = 0;\r\n+                player.matchesPlayed = 0;\r\n+                player.wins = 0;\r\n+                player.draws = 0;\r\n+                player.losses = 0;\r\n+                player.scoreDifferential = 0;\r\n+            }\r\n+        });\r\n+\r\n+        // Reset all matches for this group\r\n+        this.matches.forEach(match => {\r\n+            if (match.podId === podId) {\r\n+                match.result = undefined;\r\n+                match.completed = false;\r\n+            }\r\n+        });\r\n+    }\r\n }\r\n"
                },
                {
                    "date": 1764016797155,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -543,8 +543,16 @@\n             }\r\n         }\r\n     }\r\n \r\n+    // Update tournament name\r\n+    updateTournamentName(name: string) {\r\n+        if (!name?.trim()) {\r\n+            throw new Error(\"Tournament name cannot be empty\");\r\n+        }\r\n+        this.name = name.trim();\r\n+    }\r\n+\r\n     // Update group name\r\n     updateGroupName(podId: string, name: string) {\r\n         const pod = this.pods.find(p => p.id === podId);\r\n         if (!pod) throw new Error(\"Group not found\");\r\n"
                },
                {
                    "date": 1764018253998,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -585,5 +585,13 @@\n                 match.completed = false;\r\n             }\r\n         });\r\n     }\r\n+\r\n+    // Update player name\r\n+    updatePlayerName(playerId: string, name: string) {\r\n+        if (!name || !name.trim()) throw new Error('Name cannot be empty');\r\n+        const p = this.players.find(pl => pl.id === playerId);\r\n+        if (!p) throw new Error('Player not found');\r\n+        p.name = name.trim();\r\n+    }\r\n }\r\n"
                },
                {
                    "date": 1764022977082,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -541,8 +541,13 @@\n                     thirdPlaceMatch.player2Id = loserId;\r\n                 }\r\n             }\r\n         }\r\n+\r\n+        // If this is the final match, mark tournament as completed\r\n+        if (match.bracketType === 'finals') {\r\n+            this.state = 'completed';\r\n+        }\r\n     }\r\n \r\n     // Update tournament name\r\n     updateTournamentName(name: string) {\r\n"
                },
                {
                    "date": 1764023138476,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,9 +56,9 @@\n     players: Player[] = [];\r\n     pods: Pod[] = [];\r\n     matches: Match[] = [];\r\n     bracketMatches: BracketMatch[] = [];\r\n-    state: 'registration' | 'group' | 'playoffs' = 'registration';\r\n+    state: 'registration' | 'group' | 'playoffs' | 'completed' = 'registration';\r\n \r\n     constructor(id: string, name: string) {\r\n         this.id = id;\r\n         this.name = name;\r\n"
                },
                {
                    "date": 1764023367143,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -542,10 +542,11 @@\n                 }\r\n             }\r\n         }\r\n \r\n-        // If this is the final match, mark tournament as completed\r\n-        if (match.bracketType === 'finals') {\r\n+        // Check if all bracket matches are completed\r\n+        const allBracketMatchesCompleted = this.bracketMatches.every(m => m.winnerId);\r\n+        if (allBracketMatchesCompleted) {\r\n             this.state = 'completed';\r\n         }\r\n     }\r\n \r\n"
                },
                {
                    "date": 1764026810428,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -599,5 +599,12 @@\n         const p = this.players.find(pl => pl.id === playerId);\r\n         if (!p) throw new Error('Player not found');\r\n         p.name = name.trim();\r\n     }\r\n+\r\n+        updatePlayerPhoto(playerId: string, photo: string) {\r\n+        const p = this.players.find(pl => pl.id === playerId);\r\n+        if (!p) throw new Error('Player not found');\r\n+        p.profilePhoto = photo;\r\n+    }\r\n+\r\n }\r\n"
                },
                {
                    "date": 1764026815830,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -599,10 +599,10 @@\n         const p = this.players.find(pl => pl.id === playerId);\r\n         if (!p) throw new Error('Player not found');\r\n         p.name = name.trim();\r\n     }\r\n-\r\n-        updatePlayerPhoto(playerId: string, photo: string) {\r\n+    // Update player photo\r\n+    updatePlayerPhoto(playerId: string, photo: string) {\r\n         const p = this.players.find(pl => pl.id === playerId);\r\n         if (!p) throw new Error('Player not found');\r\n         p.profilePhoto = photo;\r\n     }\r\n"
                },
                {
                    "date": 1764026955985,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,8 +8,9 @@\n     wins: number;\r\n     draws: number;\r\n     losses: number;\r\n     scoreDifferential: number; // For tiebreakers\r\n+    profilePhoto?: string; // Base64-encoded image data\r\n }\r\n \r\n export interface Match {\r\n     id: string;\r\n@@ -599,8 +600,9 @@\n         const p = this.players.find(pl => pl.id === playerId);\r\n         if (!p) throw new Error('Player not found');\r\n         p.name = name.trim();\r\n     }\r\n+\r\n     // Update player photo\r\n     updatePlayerPhoto(playerId: string, photo: string) {\r\n         const p = this.players.find(pl => pl.id === playerId);\r\n         if (!p) throw new Error('Player not found');\r\n"
                },
                {
                    "date": 1764770167553,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,6 @@\n import { v4 as uuidv4 } from 'uuid';\r\n+import { type GameType, getGameConfig } from './gameTypes.js';\r\n \r\n export interface Player {\r\n     id: string;\r\n     name: string;\r\n@@ -7,12 +8,22 @@\n     matchesPlayed: number;\r\n     wins: number;\r\n     draws: number;\r\n     losses: number;\r\n-    scoreDifferential: number; // For tiebreakers\r\n+    scoreDifferential: number; // For tiebreakers (kills, rounds won, etc.)\r\n+    totalGameScore: number; // Total in-game score (kills, rounds, etc.)\r\n     profilePhoto?: string; // Base64-encoded image data\r\n }\r\n \r\n+// Single game result within a match (for BO3)\r\n+export interface GameResult {\r\n+    gameNumber: number; // 1, 2, or 3 for BO3\r\n+    mapName?: string;\r\n+    player1Score: number; // kills, rounds, wins depending on game\r\n+    player2Score: number;\r\n+    winnerId?: string; // Who won this specific game\r\n+}\r\n+\r\n export interface Match {\r\n     id: string;\r\n     podId: string;\r\n     round: number; // Which round this match belongs to (1, 2, or 3)\r\n@@ -22,11 +33,12 @@\n     result?: {\r\n         [playerId: string]: {\r\n             rank?: number; // 1st, 2nd, 3rd, 4th\r\n             points: number; // 3, 1, 0\r\n-            score?: number; // In-game score\r\n+            score?: number; // In-game score (kills, rounds won, etc.)\r\n         }\r\n     };\r\n+    gameResults?: GameResult[]; // Detailed results per game (for BO3 or tracking)\r\n     completed: boolean;\r\n }\r\n \r\n export interface Pod {\r\n@@ -34,10 +46,22 @@\n     round: number;\r\n     players: string[];\r\n     matchId: string;\r\n     name?: string; // Custom group name\r\n+<<<<<<< HEAD\r\n+=======\r\n }\r\n \r\n+// BO3 game result for bracket matches\r\n+export interface BracketGameResult {\r\n+    gameNumber: number;\r\n+    mapName?: string;\r\n+    player1Score: number;\r\n+    player2Score: number;\r\n+    winnerId: string;\r\n+>>>>>>> af825c2c61492a36b9eda13c09f52ada7b5ad9c2\r\n+}\r\n+\r\n export interface BracketMatch {\r\n     id: string;\r\n     round: number;\r\n     player1Id?: string;\r\n@@ -48,23 +72,43 @@\n     bracketType: 'quarterfinals' | 'semifinals' | 'finals' | '3rd-place';\r\n     matchLabel?: string; // e.g., \"Semifinal 1\", \"Grand Final\"\r\n     loserFromMatch1?: string; // For 3rd place match\r\n     loserFromMatch2?: string; // For 3rd place match\r\n+    // BO3 tracking\r\n+    games?: BracketGameResult[];\r\n+    player1Wins?: number; // Games won in the series\r\n+    player2Wins?: number;\r\n }\r\n \r\n export class TournamentManager {\r\n     id: string;\r\n     name: string;\r\n+<<<<<<< HEAD\r\n+=======\r\n+    gameType: GameType; // Which game this tournament is for\r\n+>>>>>>> af825c2c61492a36b9eda13c09f52ada7b5ad9c2\r\n     players: Player[] = [];\r\n     pods: Pod[] = [];\r\n     matches: Match[] = [];\r\n     bracketMatches: BracketMatch[] = [];\r\n     state: 'registration' | 'group' | 'playoffs' | 'completed' = 'registration';\r\n \r\n+<<<<<<< HEAD\r\n     constructor(id: string, name: string) {\r\n         this.id = id;\r\n         this.name = name;\r\n+=======\r\n+    constructor(id: string, name: string, gameType: GameType = 'cs16') {\r\n+        this.id = id;\r\n+        this.name = name;\r\n+        this.gameType = gameType;\r\n     }\r\n+    \r\n+    // Get game configuration\r\n+    getGameConfig() {\r\n+        return getGameConfig(this.gameType);\r\n+>>>>>>> af825c2c61492a36b9eda13c09f52ada7b5ad9c2\r\n+    }\r\n \r\n     addPlayer(name: string): Player {\r\n         const player: Player = {\r\n             id: uuidv4(),\r\n@@ -73,14 +117,26 @@\n             matchesPlayed: 0,\r\n             wins: 0,\r\n             draws: 0,\r\n             losses: 0,\r\n-            scoreDifferential: 0\r\n+            scoreDifferential: 0,\r\n+            totalGameScore: 0\r\n         };\r\n         this.players.push(player);\r\n         return player;\r\n     }\r\n \r\n+    removePlayer(playerId: string): void {\r\n+        if (this.state !== 'registration') {\r\n+            throw new Error(\"Cannot remove players after tournament has started\");\r\n+        }\r\n+        const index = this.players.findIndex(p => p.id === playerId);\r\n+        if (index === -1) {\r\n+            throw new Error(\"Player not found\");\r\n+        }\r\n+        this.players.splice(index, 1);\r\n+    }\r\n+\r\n     startGroupStage() {\r\n         if (this.players.length < 4) {\r\n             throw new Error(\"Need at least 4 players\");\r\n         }\r\n@@ -210,55 +266,141 @@\n             });\r\n         });\r\n     }\r\n \r\n-    submitMatchResult(matchId: string, results: { [playerId: string]: { points: number, score?: number } }) {\r\n+    submitMatchResult(matchId: string, results: { [playerId: string]: { points: number, score?: number } }, gameResults?: GameResult[]) {\r\n         const match = this.matches.find(m => m.id === matchId);\r\n         if (!match) throw new Error(\"Match not found\");\r\n \r\n         match.result = results;\r\n         match.completed = true;\r\n+        \r\n+        // Store detailed game results if provided\r\n+        if (gameResults) {\r\n+            match.gameResults = gameResults;\r\n+        }\r\n \r\n         // Update player stats\r\n         for (const [playerId, result] of Object.entries(results)) {\r\n             const player = this.players.find(p => p.id === playerId);\r\n             if (player) {\r\n                 player.matchesPlayed++;\r\n                 player.points += result.points;\r\n-                if (result.points >= 3) player.wins++; // Assuming 3 is win\r\n+                if (result.points >= 3) player.wins++; // 3 = win\r\n                 else if (result.points === 1) player.draws++;\r\n                 else player.losses++;\r\n-                // Score diff logic if needed\r\n+                \r\n+                // Track game-specific score (kills, rounds, etc.) for tiebreakers\r\n+                if (result.score !== undefined) {\r\n+                    player.totalGameScore += result.score;\r\n+                    \r\n+                    // Calculate score differential against opponent\r\n+                    const opponentId = match.player1Id === playerId ? match.player2Id : match.player1Id;\r\n+                    const opponentResult = results[opponentId];\r\n+                    if (opponentResult?.score !== undefined) {\r\n+                        player.scoreDifferential += (result.score - opponentResult.score);\r\n+                    }\r\n+                }\r\n             }\r\n         }\r\n     }\r\n \r\n+    // Submit BO3 bracket match game result\r\n+    submitBracketGameResult(matchId: string, gameResult: BracketGameResult) {\r\n+        const match = this.bracketMatches.find(m => m.id === matchId);\r\n+        if (!match) throw new Error(\"Bracket match not found\");\r\n+        \r\n+        if (!match.games) {\r\n+            match.games = [];\r\n+            match.player1Wins = 0;\r\n+            match.player2Wins = 0;\r\n+        }\r\n+        \r\n+        // Don't allow more than 3 games\r\n+        if (match.games.length >= 3) {\r\n+            throw new Error(\"BO3 match already has 3 games\");\r\n+        }\r\n+        \r\n+        // Add the game result\r\n+        match.games.push(gameResult);\r\n+        \r\n+        // Update win counts\r\n+        if (gameResult.winnerId === match.player1Id) {\r\n+            match.player1Wins = (match.player1Wins || 0) + 1;\r\n+        } else if (gameResult.winnerId === match.player2Id) {\r\n+            match.player2Wins = (match.player2Wins || 0) + 1;\r\n+        }\r\n+        \r\n+        // Check if match is won (first to 2)\r\n+        if ((match.player1Wins || 0) >= 2) {\r\n+            this.submitBracketWinner(matchId, match.player1Id!);\r\n+        } else if ((match.player2Wins || 0) >= 2) {\r\n+            this.submitBracketWinner(matchId, match.player2Id!);\r\n+        }\r\n+    }\r\n+\r\n     getRankings(): Player[] {\r\n         return [...this.players].sort((a, b) => {\r\n+            // Primary: Points\r\n             if (b.points !== a.points) return b.points - a.points;\r\n-            // Tiebreakers\r\n-            return 0; // TODO: Add tiebreakers\r\n+            \r\n+            // Tiebreaker 1: Total game score (rounds won for CS, kills for UT, etc.)\r\n+            if ((b.totalGameScore || 0) !== (a.totalGameScore || 0)) {\r\n+                return (b.totalGameScore || 0) - (a.totalGameScore || 0);\r\n+            }\r\n+            \r\n+            // Tiebreaker 2: Head-to-head result (only for 2-way tie)\r\n+            const h2hResult = this.getHeadToHeadResult(a.id, b.id);\r\n+            if (h2hResult !== 0) return h2hResult;\r\n+            \r\n+            // Tiebreaker 3: More wins\r\n+            if (b.wins !== a.wins) return b.wins - a.wins;\r\n+            \r\n+            // Tiebreaker 4: Fewer losses\r\n+            if (a.losses !== b.losses) return a.losses - b.losses;\r\n+            \r\n+            // Tiebreaker 5: Score differential (if tracked)\r\n+            if (b.scoreDifferential !== a.scoreDifferential) {\r\n+                return b.scoreDifferential - a.scoreDifferential;\r\n+            }\r\n+            \r\n+            // Tiebreaker 6: Alphabetical by name (deterministic fallback)\r\n+            return a.name.localeCompare(b.name);\r\n         });\r\n     }\r\n \r\n+    // Get head-to-head result between two players\r\n+    // Returns: positive if player B won, negative if player A won, 0 if no direct match or tie\r\n+    private getHeadToHeadResult(playerAId: string, playerBId: string): number {\r\n+        const directMatch = this.matches.find(m => \r\n+            m.completed && \r\n+            ((m.player1Id === playerAId && m.player2Id === playerBId) ||\r\n+             (m.player1Id === playerBId && m.player2Id === playerAId))\r\n+        );\r\n+        \r\n+        if (!directMatch || !directMatch.result) return 0;\r\n+        \r\n+        const aPoints = directMatch.result[playerAId]?.points || 0;\r\n+        const bPoints = directMatch.result[playerBId]?.points || 0;\r\n+        \r\n+        // Return positive if B won (B should rank higher), negative if A won\r\n+        return bPoints - aPoints;\r\n+    }\r\n+\r\n     generateBrackets() {\r\n         const rankings = this.getRankings();\r\n+        const numGroups = this.pods.length;\r\n         \r\n-        // Determine playoff size based on total players\r\n-        const totalPlayers = rankings.length;\r\n-        let numQualified: number;\r\n+        // Determine playoff size based on groups and players\r\n+        // Top 2 from each group qualify, capped at 8\r\n+        let numQualified = Math.min(numGroups * 2, 8);\r\n         \r\n-        if (totalPlayers <= 5) {\r\n-            // 4-5 players: top 4 advance\r\n-            numQualified = Math.min(4, totalPlayers);\r\n-        } else if (totalPlayers <= 8) {\r\n-            // 6-8 players: top 4 advance (simple bracket)\r\n-            numQualified = 4;\r\n-        } else if (totalPlayers <= 13) {\r\n-            // 9-13 players: top 6 advance (quarterfinals with byes)\r\n+        // Adjust to valid bracket sizes (4, 6, or 8)\r\n+        if (numQualified <= 4) {\r\n+            numQualified = Math.min(4, rankings.length);\r\n+        } else if (numQualified <= 6) {\r\n             numQualified = 6;\r\n         } else {\r\n-            // 14+ players: top 8 advance\r\n             numQualified = 8;\r\n         }\r\n         \r\n         const qualifiedPlayers = rankings.slice(0, numQualified);\r\n@@ -269,29 +411,62 @@\n     }\r\n \r\n     private createPlayoffBracket(players: Player[]) {\r\n         const numPlayers = players.length;\r\n+        const totalTournamentPlayers = this.players.length;\r\n         \r\n-        if (numPlayers === 4) {\r\n-            this.create4PlayerBracket(players);\r\n+        // Only use direct finals for exactly 4-player tournaments\r\n+        // (everyone played everyone in groups, no need for semifinals)\r\n+        // For 5+ players, always use semifinals even if single group\r\n+        if (totalTournamentPlayers === 4 && numPlayers === 4) {\r\n+            this.createDirectFinalsBracket(players);\r\n+        } else if (numPlayers === 4) {\r\n+            this.create4PlayerSemifinalsBracket(players);\r\n         } else if (numPlayers === 6) {\r\n             this.create6PlayerBracket(players);\r\n         } else if (numPlayers === 8) {\r\n             this.create8PlayerBracket(players);\r\n         } else {\r\n-            // Fallback: just create semifinals with available players\r\n-            this.create4PlayerBracket(players.slice(0, 4));\r\n+            // Fallback: create semifinals with top 4 players\r\n+            this.create4PlayerSemifinalsBracket(players.slice(0, 4));\r\n         }\r\n     }\r\n     \r\n-    private create4PlayerBracket(players: Player[]) {\r\n-        // 4 players: 2 semifinals → finals + 3rd place\r\n+    // For single group tournaments where everyone has played each other\r\n+    private createDirectFinalsBracket(players: Player[]) {\r\n+        const thirdPlaceId = uuidv4();\r\n+        const finalId = uuidv4();\r\n+        \r\n+        // Third place match: 3rd seed vs 4th seed\r\n+        this.bracketMatches.push({\r\n+            id: thirdPlaceId,\r\n+            round: 1,\r\n+            bracketType: '3rd-place',\r\n+            matchLabel: '3rd Place Match',\r\n+            player1Id: players[2]?.id,\r\n+            player2Id: players[3]?.id\r\n+        });\r\n+        \r\n+        // Final: 1st seed vs 2nd seed\r\n+        this.bracketMatches.push({\r\n+            id: finalId,\r\n+            round: 1,\r\n+            bracketType: 'finals',\r\n+            matchLabel: 'Grand Final',\r\n+            player1Id: players[0].id,\r\n+            player2Id: players[1].id\r\n+        });\r\n+    }\r\n+    \r\n+    // For multi-group tournaments - standard semifinals bracket\r\n+    private create4PlayerSemifinalsBracket(players: Player[]) {\r\n+        // 4 players from multiple groups: need semifinals since they haven't all played\r\n         const semi1Id = uuidv4();\r\n         const semi2Id = uuidv4();\r\n         const thirdPlaceId = uuidv4();\r\n         const finalId = uuidv4();\r\n         \r\n-        // Semifinals\r\n+        // Semifinals: 1v4, 2v3\r\n         this.bracketMatches.push({\r\n             id: semi1Id,\r\n             round: 1,\r\n             bracketType: 'semifinals',\r\n"
                },
                {
                    "date": 1764770812329,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,10 +46,8 @@\n     round: number;\r\n     players: string[];\r\n     matchId: string;\r\n     name?: string; // Custom group name\r\n-<<<<<<< HEAD\r\n-=======\r\n }\r\n \r\n // BO3 game result for bracket matches\r\n export interface BracketGameResult {\r\n@@ -57,9 +55,8 @@\n     mapName?: string;\r\n     player1Score: number;\r\n     player2Score: number;\r\n     winnerId: string;\r\n->>>>>>> af825c2c61492a36b9eda13c09f52ada7b5ad9c2\r\n }\r\n \r\n export interface BracketMatch {\r\n     id: string;\r\n@@ -81,23 +78,15 @@\n \r\n export class TournamentManager {\r\n     id: string;\r\n     name: string;\r\n-<<<<<<< HEAD\r\n-=======\r\n     gameType: GameType; // Which game this tournament is for\r\n->>>>>>> af825c2c61492a36b9eda13c09f52ada7b5ad9c2\r\n     players: Player[] = [];\r\n     pods: Pod[] = [];\r\n     matches: Match[] = [];\r\n     bracketMatches: BracketMatch[] = [];\r\n     state: 'registration' | 'group' | 'playoffs' | 'completed' = 'registration';\r\n \r\n-<<<<<<< HEAD\r\n-    constructor(id: string, name: string) {\r\n-        this.id = id;\r\n-        this.name = name;\r\n-=======\r\n     constructor(id: string, name: string, gameType: GameType = 'cs16') {\r\n         this.id = id;\r\n         this.name = name;\r\n         this.gameType = gameType;\r\n@@ -105,9 +94,8 @@\n     \r\n     // Get game configuration\r\n     getGameConfig() {\r\n         return getGameConfig(this.gameType);\r\n->>>>>>> af825c2c61492a36b9eda13c09f52ada7b5ad9c2\r\n     }\r\n \r\n     addPlayer(name: string): Player {\r\n         const player: Player = {\r\n"
                }
            ],
            "date": 1763989257102,
            "name": "Commit-0",
            "content": "import { v4 as uuidv4 } from 'uuid';\r\n\r\nexport interface Player {\r\n    id: string;\r\n    name: string;\r\n    points: number;\r\n    matchesPlayed: number;\r\n    wins: number;\r\n    draws: number;\r\n    losses: number;\r\n    scoreDifferential: number; // For tiebreakers\r\n}\r\n\r\nexport interface Match {\r\n    id: string;\r\n    podId: string;\r\n    round: number; // Which round this match belongs to (1, 2, or 3)\r\n    player1Id: string;\r\n    player2Id: string;\r\n    players: string[]; // IDs of players in this match\r\n    result?: {\r\n        [playerId: string]: {\r\n            rank?: number; // 1st, 2nd, 3rd, 4th\r\n            points: number; // 3, 1, 0\r\n            score?: number; // In-game score\r\n        }\r\n    };\r\n    completed: boolean;\r\n}\r\n\r\nexport interface Pod {\r\n    id: string;\r\n    round: number;\r\n    players: string[];\r\n    matchId: string;\r\n}\r\n\r\nexport interface BracketMatch {\r\n    id: string;\r\n    round: number;\r\n    player1Id?: string;\r\n    player2Id?: string;\r\n    winnerId?: string;\r\n    nextMatchId?: string; // Where the winner goes\r\n    nextMatchSlot?: 1 | 2; // Player 1 or Player 2 slot\r\n    bracketType: 'quarterfinals' | 'semifinals' | 'finals' | '3rd-place';\r\n    matchLabel?: string; // e.g., \"Semifinal 1\", \"Grand Final\"\r\n    loserFromMatch1?: string; // For 3rd place match\r\n    loserFromMatch2?: string; // For 3rd place match\r\n}\r\n\r\nexport class TournamentManager {\r\n    id: string;\r\n    name: string;\r\n    players: Player[] = [];\r\n    pods: Pod[] = [];\r\n    matches: Match[] = [];\r\n    bracketMatches: BracketMatch[] = [];\r\n    state: 'registration' | 'group' | 'playoffs' = 'registration';\r\n\r\n    constructor(id: string, name: string) {\r\n        this.id = id;\r\n        this.name = name;\r\n    }\r\n\r\n    addPlayer(name: string): Player {\r\n        const player: Player = {\r\n            id: uuidv4(),\r\n            name,\r\n            points: 0,\r\n            matchesPlayed: 0,\r\n            wins: 0,\r\n            draws: 0,\r\n            losses: 0,\r\n            scoreDifferential: 0\r\n        };\r\n        this.players.push(player);\r\n        return player;\r\n    }\r\n\r\n    startGroupStage() {\r\n        if (this.players.length < 4) {\r\n            throw new Error(\"Need at least 4 players\");\r\n        }\r\n        this.state = 'group';\r\n        this.generatePods();\r\n    }\r\n\r\n    private generatePods() {\r\n        const numPlayers = this.players.length;\r\n        \r\n        // Determine group size and count\r\n        let groupSize = 4;\r\n        let numGroups = 1;\r\n        \r\n        if (numPlayers === 4) {\r\n            groupSize = 4;\r\n            numGroups = 1;\r\n        } else if (numPlayers === 5) {\r\n            groupSize = 5;\r\n            numGroups = 1;\r\n        } else if (numPlayers === 6) {\r\n            groupSize = 3;\r\n            numGroups = 2;\r\n        } else if (numPlayers === 7) {\r\n            groupSize = 7;\r\n            numGroups = 1;\r\n        } else if (numPlayers === 8) {\r\n            groupSize = 4;\r\n            numGroups = 2;\r\n        } else if (numPlayers === 9) {\r\n            groupSize = 3;\r\n            numGroups = 3;\r\n        } else if (numPlayers >= 10 && numPlayers <= 12) {\r\n            groupSize = 4;\r\n            numGroups = Math.ceil(numPlayers / 4);\r\n        } else {\r\n            // For larger numbers, try to make groups of 4\r\n            groupSize = 4;\r\n            numGroups = Math.ceil(numPlayers / 4);\r\n        }\r\n        \r\n        // Shuffle and divide players into groups\r\n        const shuffled = [...this.players].sort(() => Math.random() - 0.5);\r\n        const groups: Player[][] = [];\r\n        \r\n        for (let g = 0; g < numGroups; g++) {\r\n            groups.push([]);\r\n        }\r\n        \r\n        // Distribute players evenly\r\n        shuffled.forEach((player, index) => {\r\n            groups[index % numGroups].push(player);\r\n        });\r\n        \r\n        // For each group, generate complete round-robin matches\r\n        groups.forEach((groupPlayers, groupIndex) => {\r\n            const podId = uuidv4();\r\n            \r\n            // Store pod with all players in this group\r\n            this.pods.push({\r\n                id: podId,\r\n                round: 1, // All belong to the same logical group\r\n                players: groupPlayers.map(p => p.id),\r\n                matchId: '' // Will be set later\r\n            });\r\n            \r\n            // Generate complete round-robin: every player plays every other player once\r\n            const n = groupPlayers.length;\r\n            \r\n            if (n < 2) return; // Need at least 2 players\r\n            \r\n            // For round-robin, generate all unique pairs\r\n            const allMatches: [Player, Player][] = [];\r\n            for (let i = 0; i < n; i++) {\r\n                for (let j = i + 1; j < n; j++) {\r\n                    allMatches.push([groupPlayers[i], groupPlayers[j]]);\r\n                }\r\n            }\r\n            \r\n            // Distribute matches across rounds to minimize conflicts\r\n            // Use round-robin scheduling algorithm\r\n            const totalMatches = allMatches.length;\r\n            const matchesPerRound = Math.floor(n / 2);\r\n            const totalRounds = n % 2 === 0 ? n - 1 : n;\r\n            \r\n            const schedule: [Player, Player][][] = [];\r\n            const playersCopy = [...groupPlayers];\r\n            \r\n            for (let round = 0; round < totalRounds; round++) {\r\n                const roundMatches: [Player, Player][] = [];\r\n                \r\n                for (let i = 0; i < matchesPerRound; i++) {\r\n                    const p1 = playersCopy[i];\r\n                    const p2 = playersCopy[n - 1 - i];\r\n                    if (p1 && p2) {\r\n                        roundMatches.push([p1, p2]);\r\n                    }\r\n                }\r\n                \r\n                schedule.push(roundMatches);\r\n                \r\n                // Rotate players for next round (keep first player fixed)\r\n                if (n % 2 === 0) {\r\n                    // For even number of players, rotate all except first\r\n                    const last = playersCopy.pop()!;\r\n                    playersCopy.splice(1, 0, last);\r\n                } else {\r\n                    // For odd number of players, rotate all\r\n                    playersCopy.push(playersCopy.shift()!);\r\n                }\r\n            }\r\n            \r\n            // Create matches for each round\r\n            schedule.forEach((roundMatches, roundIndex) => {\r\n                roundMatches.forEach(([p1, p2]) => {\r\n                    const matchId = uuidv4();\r\n                    this.matches.push({\r\n                        id: matchId,\r\n                        podId,\r\n                        round: roundIndex + 1, // Store the round number\r\n                        player1Id: p1.id,\r\n                        player2Id: p2.id,\r\n                        players: [p1.id, p2.id],\r\n                        completed: false\r\n                    });\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    submitMatchResult(matchId: string, results: { [playerId: string]: { points: number, score?: number } }) {\r\n        const match = this.matches.find(m => m.id === matchId);\r\n        if (!match) throw new Error(\"Match not found\");\r\n\r\n        match.result = results;\r\n        match.completed = true;\r\n\r\n        // Update player stats\r\n        for (const [playerId, result] of Object.entries(results)) {\r\n            const player = this.players.find(p => p.id === playerId);\r\n            if (player) {\r\n                player.matchesPlayed++;\r\n                player.points += result.points;\r\n                if (result.points >= 3) player.wins++; // Assuming 3 is win\r\n                else if (result.points === 1) player.draws++;\r\n                else player.losses++;\r\n                // Score diff logic if needed\r\n            }\r\n        }\r\n    }\r\n\r\n    getRankings(): Player[] {\r\n        return [...this.players].sort((a, b) => {\r\n            if (b.points !== a.points) return b.points - a.points;\r\n            // Tiebreakers\r\n            return 0; // TODO: Add tiebreakers\r\n        });\r\n    }\r\n\r\n    generateBrackets() {\r\n        const rankings = this.getRankings();\r\n        \r\n        // Determine playoff size based on total players\r\n        const totalPlayers = rankings.length;\r\n        let numQualified: number;\r\n        \r\n        if (totalPlayers <= 5) {\r\n            // 4-5 players: top 4 advance\r\n            numQualified = Math.min(4, totalPlayers);\r\n        } else if (totalPlayers <= 8) {\r\n            // 6-8 players: top 4 advance (simple bracket)\r\n            numQualified = 4;\r\n        } else if (totalPlayers <= 13) {\r\n            // 9-13 players: top 6 advance (quarterfinals with byes)\r\n            numQualified = 6;\r\n        } else {\r\n            // 14+ players: top 8 advance\r\n            numQualified = 8;\r\n        }\r\n        \r\n        const qualifiedPlayers = rankings.slice(0, numQualified);\r\n\r\n        this.bracketMatches = [];\r\n        this.createPlayoffBracket(qualifiedPlayers);\r\n        this.state = 'playoffs';\r\n    }\r\n\r\n    private createPlayoffBracket(players: Player[]) {\r\n        const numPlayers = players.length;\r\n        \r\n        if (numPlayers === 4) {\r\n            this.create4PlayerBracket(players);\r\n        } else if (numPlayers === 6) {\r\n            this.create6PlayerBracket(players);\r\n        } else if (numPlayers === 8) {\r\n            this.create8PlayerBracket(players);\r\n        } else {\r\n            // Fallback: just create semifinals with available players\r\n            this.create4PlayerBracket(players.slice(0, 4));\r\n        }\r\n    }\r\n    \r\n    private create4PlayerBracket(players: Player[]) {\r\n        // 4 players: 2 semifinals → finals + 3rd place\r\n        const semi1Id = uuidv4();\r\n        const semi2Id = uuidv4();\r\n        const thirdPlaceId = uuidv4();\r\n        const finalId = uuidv4();\r\n        \r\n        // Semifinals\r\n        this.bracketMatches.push({\r\n            id: semi1Id,\r\n            round: 1,\r\n            bracketType: 'semifinals',\r\n            matchLabel: 'Semifinal 1',\r\n            player1Id: players[0].id, // 1st seed\r\n            player2Id: players[3].id, // 4th seed\r\n            nextMatchId: finalId,\r\n            nextMatchSlot: 1\r\n        });\r\n        \r\n        this.bracketMatches.push({\r\n            id: semi2Id,\r\n            round: 1,\r\n            bracketType: 'semifinals',\r\n            matchLabel: 'Semifinal 2',\r\n            player1Id: players[1].id, // 2nd seed\r\n            player2Id: players[2].id, // 3rd seed\r\n            nextMatchId: finalId,\r\n            nextMatchSlot: 2\r\n        });\r\n        \r\n        // Third place match\r\n        this.bracketMatches.push({\r\n            id: thirdPlaceId,\r\n            round: 2,\r\n            bracketType: '3rd-place',\r\n            matchLabel: '3rd Place Match',\r\n            loserFromMatch1: semi1Id,\r\n            loserFromMatch2: semi2Id\r\n        });\r\n        \r\n        // Final\r\n        this.bracketMatches.push({\r\n            id: finalId,\r\n            round: 2,\r\n            bracketType: 'finals',\r\n            matchLabel: 'Grand Final'\r\n        });\r\n    }\r\n    \r\n    private create6PlayerBracket(players: Player[]) {\r\n        // 6 players: 2 quarterfinals → 2 semifinals → finals + 3rd place\r\n        // Seeds 1 and 2 get automatic advancement to semifinals (no bye matches shown)\r\n        // Seeds 3-6 play in quarterfinals\r\n        \r\n        const quarter1Id = uuidv4();\r\n        const quarter2Id = uuidv4();\r\n        const semi1Id = uuidv4();\r\n        const semi2Id = uuidv4();\r\n        const thirdPlaceId = uuidv4();\r\n        const finalId = uuidv4();\r\n        \r\n        // Quarterfinals (2 matches)\r\n        // Match 1: 3rd vs 6th → winner plays 2nd seed\r\n        this.bracketMatches.push({\r\n            id: quarter1Id,\r\n            round: 1,\r\n            bracketType: 'quarterfinals',\r\n            matchLabel: 'Quarterfinal 1',\r\n            player1Id: players[2].id, // 3rd seed\r\n            player2Id: players[5].id, // 6th seed\r\n            nextMatchId: semi2Id,\r\n            nextMatchSlot: 2\r\n        });\r\n        \r\n        // Match 2: 4th vs 5th → winner plays 1st seed\r\n        this.bracketMatches.push({\r\n            id: quarter2Id,\r\n            round: 1,\r\n            bracketType: 'quarterfinals',\r\n            matchLabel: 'Quarterfinal 2',\r\n            player1Id: players[3].id, // 4th seed\r\n            player2Id: players[4].id, // 5th seed\r\n            nextMatchId: semi1Id,\r\n            nextMatchSlot: 2\r\n        });\r\n        \r\n        // Semifinals (2 matches)\r\n        // Semi 1: 1st seed (bye) vs winner of QF2\r\n        this.bracketMatches.push({\r\n            id: semi1Id,\r\n            round: 2,\r\n            bracketType: 'semifinals',\r\n            matchLabel: 'Semifinal 1',\r\n            player1Id: players[0].id, // 1st seed (bye)\r\n            // player2Id filled by QF2 winner\r\n            nextMatchId: finalId,\r\n            nextMatchSlot: 1\r\n        });\r\n        \r\n        // Semi 2: 2nd seed (bye) vs winner of QF1\r\n        this.bracketMatches.push({\r\n            id: semi2Id,\r\n            round: 2,\r\n            bracketType: 'semifinals',\r\n            matchLabel: 'Semifinal 2',\r\n            player1Id: players[1].id, // 2nd seed (bye)\r\n            // player2Id filled by QF1 winner\r\n            nextMatchId: finalId,\r\n            nextMatchSlot: 2\r\n        });\r\n        \r\n        // Third place match\r\n        this.bracketMatches.push({\r\n            id: thirdPlaceId,\r\n            round: 3,\r\n            bracketType: '3rd-place',\r\n            matchLabel: '3rd Place Match',\r\n            loserFromMatch1: semi1Id,\r\n            loserFromMatch2: semi2Id\r\n        });\r\n        \r\n        // Final\r\n        this.bracketMatches.push({\r\n            id: finalId,\r\n            round: 3,\r\n            bracketType: 'finals',\r\n            matchLabel: 'Grand Final'\r\n        });\r\n    }\r\n    \r\n    private create8PlayerBracket(players: Player[]) {\r\n        // 8 players: 4 quarterfinals → 2 semifinals → finals + 3rd place\r\n        \r\n        const quarter1Id = uuidv4();\r\n        const quarter2Id = uuidv4();\r\n        const quarter3Id = uuidv4();\r\n        const quarter4Id = uuidv4();\r\n        const semi1Id = uuidv4();\r\n        const semi2Id = uuidv4();\r\n        const thirdPlaceId = uuidv4();\r\n        const finalId = uuidv4();\r\n        \r\n        // Quarterfinals (4 matches)\r\n        this.bracketMatches.push({\r\n            id: quarter1Id,\r\n            round: 1,\r\n            bracketType: 'quarterfinals',\r\n            matchLabel: 'Quarterfinal 1',\r\n            player1Id: players[0].id, // 1st vs 8th\r\n            player2Id: players[7].id,\r\n            nextMatchId: semi1Id,\r\n            nextMatchSlot: 1\r\n        });\r\n        \r\n        this.bracketMatches.push({\r\n            id: quarter2Id,\r\n            round: 1,\r\n            bracketType: 'quarterfinals',\r\n            matchLabel: 'Quarterfinal 2',\r\n            player1Id: players[3].id, // 4th vs 5th\r\n            player2Id: players[4].id,\r\n            nextMatchId: semi1Id,\r\n            nextMatchSlot: 2\r\n        });\r\n        \r\n        this.bracketMatches.push({\r\n            id: quarter3Id,\r\n            round: 1,\r\n            bracketType: 'quarterfinals',\r\n            matchLabel: 'Quarterfinal 3',\r\n            player1Id: players[1].id, // 2nd vs 7th\r\n            player2Id: players[6].id,\r\n            nextMatchId: semi2Id,\r\n            nextMatchSlot: 1\r\n        });\r\n        \r\n        this.bracketMatches.push({\r\n            id: quarter4Id,\r\n            round: 1,\r\n            bracketType: 'quarterfinals',\r\n            matchLabel: 'Quarterfinal 4',\r\n            player1Id: players[2].id, // 3rd vs 6th\r\n            player2Id: players[5].id,\r\n            nextMatchId: semi2Id,\r\n            nextMatchSlot: 2\r\n        });\r\n        \r\n        // Semifinals (2 matches)\r\n        this.bracketMatches.push({\r\n            id: semi1Id,\r\n            round: 2,\r\n            bracketType: 'semifinals',\r\n            matchLabel: 'Semifinal 1',\r\n            nextMatchId: finalId,\r\n            nextMatchSlot: 1\r\n        });\r\n        \r\n        this.bracketMatches.push({\r\n            id: semi2Id,\r\n            round: 2,\r\n            bracketType: 'semifinals',\r\n            matchLabel: 'Semifinal 2',\r\n            nextMatchId: finalId,\r\n            nextMatchSlot: 2\r\n        });\r\n        \r\n        // Third place match\r\n        this.bracketMatches.push({\r\n            id: thirdPlaceId,\r\n            round: 3,\r\n            bracketType: '3rd-place',\r\n            matchLabel: '3rd Place Match',\r\n            loserFromMatch1: semi1Id,\r\n            loserFromMatch2: semi2Id\r\n        });\r\n        \r\n        // Final\r\n        this.bracketMatches.push({\r\n            id: finalId,\r\n            round: 3,\r\n            bracketType: 'finals',\r\n            matchLabel: 'Grand Final'\r\n        });\r\n    }\r\n\r\n    submitBracketWinner(matchId: string, winnerId: string) {\r\n        const match = this.bracketMatches.find(m => m.id === matchId);\r\n        if (!match) throw new Error(\"Match not found\");\r\n        \r\n        if (match.player1Id !== winnerId && match.player2Id !== winnerId) {\r\n            throw new Error(\"Winner must be one of the players in the match\");\r\n        }\r\n\r\n        match.winnerId = winnerId;\r\n        const loserId = match.player1Id === winnerId ? match.player2Id : match.player1Id;\r\n        \r\n        // Advance winner to next match\r\n        if (match.nextMatchId) {\r\n            const nextMatch = this.bracketMatches.find(m => m.id === match.nextMatchId);\r\n            if (nextMatch) {\r\n                if (match.nextMatchSlot === 1) {\r\n                    nextMatch.player1Id = winnerId;\r\n                } else {\r\n                    nextMatch.player2Id = winnerId;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // If this is a semifinal, send loser to third place match\r\n        if (match.bracketType === 'semifinals') {\r\n            const thirdPlaceMatch = this.bracketMatches.find(m => m.bracketType === '3rd-place');\r\n            if (thirdPlaceMatch && loserId) {\r\n                // Add loser to third place match\r\n                if (!thirdPlaceMatch.player1Id) {\r\n                    thirdPlaceMatch.player1Id = loserId;\r\n                } else if (!thirdPlaceMatch.player2Id) {\r\n                    thirdPlaceMatch.player2Id = loserId;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"
        }
    ]
}